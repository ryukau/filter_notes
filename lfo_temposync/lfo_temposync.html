<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja" >

<head>
<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="dcterms.date" content="2021-05-09" />
<title>lfo_temposync</title>

<!-- KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
onload="renderMathInElement(document.body);"></script>

<style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #666666;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #666666;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; text-decoration: underline; } /* Alert */
code span.an { color: #666666; font-style: italic; } /* Annotation */
code span.at { color: #906000; } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #000000; font-weight: bold; } /* ControlFlow */
code span.ch { color: #b000b0; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008800; } /* Comment */
code span.cv { color: #008800; } /* CommentVar */
code span.do { color: #008800; } /* Documentation */
code span.dt { color: #906000; } /* DataType */
code span.dv { color: #0000ff; } /* DecVal */
code span.er { color: #ffffff; background-color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000ff; } /* Float */
code span.im { color: #000000; font-weight: bold; } /* Import */
code span.in { color: #666666; } /* Information */
code span.kw { color: #000000; font-weight: bold; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #000000; } /* Other */
code span.pp { color: #000000; font-weight: bold; } /* Preprocessor */
code span.sc { color: #b000b0; } /* SpecialChar */
code span.ss { color: #b000b0; } /* SpecialString */
code span.st { color: #b000b0; } /* String */
code span.va { color: #000088; } /* Variable */
code span.vs { color: #b000b0; } /* VerbatimString */
code span.wa { background-color: #ffff00; font-weight: bold; font-style: italic; text-decoration: underline; } /* Warning */
</style>
<style>
body {
max-width: 704px;
margin: auto;
padding: 32px 8px;
}

img {
max-width: 100%;
}

video {
max-width: 100%;
}

kbd {
font-family: inherit;
border-style: solid;
border-width: 1px 2px 2px 1px;
border-radius: 2px;
padding: 4px;
margin: 2px;
line-height: calc(1em + 16px);
}

a {
text-decoration: none;
}

h2 {
border-left: solid 32px #000000;
padding-left: 24px;
}

h3 {
border-left: solid 20px #404040;
padding-left: 16px;
}

h4 {
border-left: solid 12px #606060;
padding-left: 8px;
}

h5 {
border-left: solid 4px #808080;
padding-left: 4px;
}

h6 {
border-left: solid 2px #a0a0a0;
padding-left: 2px;
}

table {
border-spacing: 0px;
border-collapse: separate;
border-left: 1px solid #888888;
border-right: 1px solid #888888;
border-top: 1px solid #888888;
border-bottom: hidden;
}

tr:nth-child(odd) {
background: #eeeeee;
}

tr:nth-child(even) {
background: #ffffff;
}

th {
height: 2em;
padding: 4px 1em 4px 1em;
background: #ffffff;
border-bottom: 1px solid #888888;
}

th:not(:first-child) {
border-left: 1px solid #888888;
}

td {
height: 1.5em;
padding: 4px 1em 4px 1em;
border-bottom: 1px solid #888888;
}

td:not(:first-child) {
border-left: 1px solid #888888;
}

dl {
padding-left: 2em;
}

dt {
font-weight: bold;
border-bottom: 1px dashed #000000;
margin-top: 2em;
}

dd {
border-left: 1px dotted #000000;
margin-left: 1em;
padding-left: 1em;
}

audio {
vertical-align: middle;
}

label {
vertical-align: middle;
}

:not(.sourceCode)>pre {
overflow: auto;
border: 1px solid #888888;
padding: 8px;
}

div.sourceCode {
overflow: auto;
border: 1px solid #888888;
padding: 8px;
}

pre>code.sourceCode>span>a:first-child::before {
border-right: 1px solid #888888;
padding-right: 1em;
margin-right: 1em;
text-decoration: none;
}

:not(pre)>code {
color: #163eac;
}

li {
margin: 8px;
}

summary:hover {
background-color: #eeeeee;
}

header {
border-bottom: 1px gray solid;
padding: 0.5em;
margin-bottom: 1em;
}

footer {
border-top: 1px gray solid;
padding: 0.5em;
margin-top: 1em;
}


canvas {
/* image-rendering: pixelated; */
display: inline-block;
border-style: solid;
border-width: 1px;
border-color: #627f84;
}

.controlBlock {
display: inline-block;
width: 450px;
text-align: left;
vertical-align: top;
margin-left: 4px;
}

input[type="button"] {
background-color: #ffffff;
border: 2px solid #aaaaaa;
font-size: 16px;
height: 32px;
}

input[type="button"]:hover {
background-color: #ffffff;
border: 2px solid #aaccff;
}

div.numberInput {
display: block;
white-space: nowrap;
}

div.numberInput:hover {
background-color: #e0ecff;
}

.numberInputLabel {
/* max 12 letter  */
display: inline-block;
margin: 0 8px 0 8px;
text-align: left;
vertical-align: middle;
width: 100px;

font-size: 10pt;
font-family: 'Courier New', Courier, monospace;
}

.numberInputNumber {
display: inline-block;
vertical-align: middle;
width: 120px;
}

.numberInputRange {
display: inline-block;
vertical-align: middle;
width: 160px;
}

.pullDownMenu {
display: inline-block;
text-align: center;
}

.pullDownMenu:hover {
background-color: #e0ecff;
}

select {
background-color: #ffffff;
border: 2px solid #aaaaaa;
height: 24px;
vertical-align: middle;
font-size: 12px;
}

select:hover {
background-color: #ffffff;
border: 2px solid #aaccff;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>

<body>
<header>
<p>
何かあれば <a href="https://github.com/ryukau/filter_notes">GitHub のリポジトリ</a>に issue を作るか ryukau@gmail.com までお気軽にどうぞ。
</p>
<hr>
<a href="../index.html">インデックスに戻る</a>
<p>
Update: 2021-05-09
</p>
<details>
<summary translate="yes">Table of Contents</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#lfo-のテンポシンク">LFO のテンポシンク</a><ul>
<li><a href="#素朴なテンポシンク">素朴なテンポシンク</a><ul>
<li><a href="#評価">評価</a><ul>
<li><a href="#同期間隔の変更">同期間隔の変更</a></li>
<li><a href="#テンポの変更">テンポの変更</a></li>
</ul></li>
</ul></li>
<li><a href="#滑らかなテンポシンク">滑らかなテンポシンク</a><ul>
<li><a href="#問題の整理">問題の整理</a></li>
<li><a href="#設計">設計</a></li>
<li><a href="#逆走の補正">逆走の補正</a></li>
</ul></li>
<li><a href="#実装">実装</a><ul>
<li><a href="#経過拍数の外挿">経過拍数の外挿</a></li>
<li><a href="#状態遷移">状態遷移</a></li>
<li><a href="#計算式の再掲">計算式の再掲</a></li>
<li><a href="#c-での実装">C++ での実装</a></li>
</ul></li>
<li><a href="#音のサンプル">音のサンプル</a><ul>
<li><a href="#同期間隔の変更-1">同期間隔の変更</a></li>
<li><a href="#テンポの変更-1">テンポの変更</a></li>
</ul></li>
<li><a href="#その他">その他</a><ul>
<li><a href="#位相の計算式の変形">位相の計算式の変形</a></li>
<li><a href="#テンポシンクに必要な情報の取得">テンポシンクに必要な情報の取得</a></li>
</ul></li>
<li><a href="#変更点">変更点</a></li>
</ul></li>
</ul>
</nav>
</details>
</header>
<h1 id="lfo-のテンポシンク">LFO のテンポシンク</h1>
<p>LFO を滑らかにテンポシンク (tempo synchronization) する方法について調べます。</p>
<p>ここでは拍単位でのテンポシンクのみを扱います。</p>
<h2 id="素朴なテンポシンク">素朴なテンポシンク</h2>
<p>テンポシンクでは以下のパラメータを使います。ユーザはテンポと同期間隔を変更できます。</p>
<ul>
<li><span class="math inline">\(T\)</span>: テンポ [beat/min]</li>
<li><span class="math inline">\(B\)</span>: 経過拍数 [beat]</li>
<li><span class="math inline">\(S\)</span>: 同期間隔 [beat]</li>
</ul>
<p>経過拍数 <span class="math inline">\(B\)</span> と同期間隔 <span class="math inline">\(S\)</span> から LFO の位相 <span class="math inline">\(p\)</span> を以下の式で計算できます。</p>
<p><span class="math display">\[
p = \frac{\mathrm{fmod}(B, S)}{S}
\]</span></p>
<p>上の式による位相の計算を、素朴なテンポシンクと呼ぶことにします。位相 <span class="math inline">\(p\)</span> は範囲 <span class="math inline">\([0, 1)\)</span> の、のこぎり波の LFO として使えます。</p>
<h3 id="評価">評価</h3>
<p>振幅変調を使って評価を行います。</p>
<h4 id="同期間隔の変更">同期間隔の変更</h4>
<p>以下のパラメータでテンポシンクを行います。</p>
<ul>
<li>テンポ 120 [beat/min]</li>
<li>同期間隔
<ul>
<li>0~1 秒: 6/5 [beat]</li>
<li>1~2 秒: 2 [beat]</li>
</ul></li>
</ul>
<p>次の図は同期間隔のプロットです。 1 秒の時点で同期間隔が 6/5 拍から 2 拍に変わります。</p>
<figure>
<img src="img/SyncChangeSyncIntervalStep.svg" alt="Image of sync interval." style="padding-bottom: 12px;"/>
</figure>
<p>次の図は上記のパラメータから計算した、素朴なテンポシンクの位相 <span class="math inline">\(p\)</span> のプロットです。この信号は開始から 1 秒の時点で 1.0 に到達せずに 0.0 に巻き戻っているので、位相として使うには問題があります。</p>
<figure>
<img src="img/SyncChangeLfoPhaseStep.svg" alt="Image of LFO phase." style="padding-bottom: 12px;"/>
</figure>
<p>位相 <span class="math inline">\(p\)</span> をサイン波 <span class="math inline">\(s_m\)</span> に変換します。 1 秒の時点に不連続点があります。</p>
<p><span class="math display">\[
s_m = \sin(2 \pi p)
\]</span></p>
<figure>
<img src="img/SyncChangeAmModulatorStep.svg" alt="Image of sin wave LFO." style="padding-bottom: 12px;"/>
</figure>
<p>次の図は 1000 Hz のサイン波をキャリア、 <span class="math inline">\(s_m\)</span> をモジュレータとして振幅変調をかけたときのスペクトログラムです。 1 秒の時点に入っている、明るい縦の線がポップノイズです。</p>
<figure>
<img src="img/NaiveSyncChange.png" alt="Spectrogram of amplitude modulated signal. Modulator is naively tempo synced LFO with constant tempo and changing sync interval." style="padding-bottom: 12px;"/>
</figure>
<p>音のサンプルです。</p>
<figure>
<figcaption>
素朴にテンポシンクした LFO で 1000 Hz のサイン波に振幅変調をかけて、同期間隔を変更したときの音。
</figcaption>
<audio controls>
<source src="snd/NaiveSyncChange.wav" type="audio/wav">
</audio>
</figure>
<h4 id="テンポの変更">テンポの変更</h4>
<p>以下のパラメータでテンポシンクを行います。</p>
<ul>
<li>テンポ
<ul>
<li>0~1 秒: 40 [beat/min]</li>
<li>1~2 秒: 120 [beat/min]</li>
</ul></li>
<li>同期間隔 1 [beat]</li>
</ul>
<p>以下の図は 1 秒の時点でテンポが変更されたときの位相のプロットです。テンポが変更された時点で、位相の傾きが変わっています。</p>
<figure>
<img src="img/TempoChangeLfoPhaseStep.svg" alt="Image of LFO phase." style="padding-bottom: 12px;"/>
</figure>
<p>次の図は、上の図の位相を使ったサイン波をモジュレータとして、 1000 Hz のサイン波のキャリアに振幅変調をかけたときのスペクトログラムです。 1 秒の時点で少しだけ縦に伸びている線がポップノイズです。同期間隔を変更したときに比べるとポップノイズは目立ちません。</p>
<figure>
<img src="img/NaiveTempoChange.png" alt="Spectrogram of amplitude modulated signal. Modulator is naively tempo synced LFO with changing tempo and constant sync interval." style="padding-bottom: 12px;"/>
</figure>
<p>音のサンプルです。ポップノイズを聞き取ることは困難です。</p>
<figure>
<figcaption>
素朴にテンポシンクされた LFO による振幅変調。テンポを変更。
</figcaption>
<audio controls>
<source src="snd/NaiveTempoChange.wav" type="audio/wav">
</audio>
</figure>
<h2 id="滑らかなテンポシンク">滑らかなテンポシンク</h2>
<p>同期間隔やテンポが変更されたときにポップノイズを抑えながら新しい周期に移行するような方法を調べます。</p>
<h3 id="問題の整理">問題の整理</h3>
<p>ある時点で同期間隔が <span class="math inline">\(S_0\)</span> から <span class="math inline">\(S_1\)</span> に変わったとします。このとき、パラメータ変更前の位相の位置 <span class="math inline">\(p_0\)</span> と、パラメータ変更後の位相の位置 <span class="math inline">\(p_1\)</span> は以下の式で計算できます。</p>
<p><span class="math display">\[
\begin{aligned}
p_0 &amp;= \frac{\mathrm{fmod}(B, S_0)}{S_0}\\
p_1 &amp;= \frac{\mathrm{fmod}(B, S_1)}{S_1}\\
\end{aligned}
\]</span></p>
<p>同様にテンポが <span class="math inline">\(T_0\)</span> から <span class="math inline">\(T_1\)</span> に変わったとします。またサンプリング周波数を <span class="math inline">\(f_s\)</span> とします。このとき、パラメータ変更前の 1 サンプルあたりの位相の傾き <span class="math inline">\(v_0\)</span> と、パラメータ変更後の 1 サンプルあたりの位相の傾き <span class="math inline">\(v_1\)</span> は以下の式で計算できます。分母の 60 は 1 分間の秒数です。</p>
<p><span class="math display">\[
\begin{aligned}
v_0 &amp;= \frac{T_0}{60 f_s S_0}\\
v_1 &amp;= \frac{T_1}{60 f_s S_1}\\
\end{aligned}
\]</span></p>
<p>この問題の目的は、位置 <span class="math inline">\(p_0\)</span> かつ速度 <span class="math inline">\(v_0\)</span> の位相 <span class="math inline">\(\phi_0\)</span> を、位置 <span class="math inline">\(p_1\)</span> かつ速度 <span class="math inline">\(v_1\)</span> の位相 <span class="math inline">\(\phi_1\)</span> に並走させることです。以下は <span class="math inline">\(\phi_0\)</span> と <span class="math inline">\(\phi_1\)</span> の位置関係を示した図です。青が <span class="math inline">\(\phi_0\)</span> 、オレンジが <span class="math inline">\(\phi_1\)</span> を表しています。ここで扱っている位相は <span class="math inline">\(0\)</span> 未満あるいは <span class="math inline">\(1\)</span> 以上のときに <span class="math inline">\([0, 1)\)</span> の範囲へと巻き戻されます。下図の <span class="math inline">\([-1, 0)\)</span> と <span class="math inline">\([1, 2)\)</span> の範囲に含まれる矢印は巻き戻す前の位相を表しています。</p>
<figure>
<img src="img/PhaseWrapAround.svg" alt="Abstract plot of phase and its wrap around images." style="padding-bottom: 12px;"/>
</figure>
<p>ここで <span class="math inline">\(p_0\)</span> から <span class="math inline">\(p_1\)</span> に滑らかに遷移するときの速度を <span class="math inline">\(v_2\)</span> とします。以下は <span class="math inline">\(v_2\)</span> に求められる性質を示した図です。</p>
<figure>
<img src="img/VelocityAreaConcept.svg" alt="Plot of the relation between v2 curve and distance d of p0 and p1." style="padding-bottom: 12px;"/>
</figure>
<p><span class="math inline">\(v_0\)</span> から <span class="math inline">\(v_1\)</span> をつなぐ曲線 <span class="math inline">\(v_2\)</span> は、以下の条件を満たせば自由に定義できます。</p>
<p><span class="math display">\[
\int_{0}^{t_L} v_2(t)\ dt = d
\]</span></p>
<p><span class="math inline">\(v_2\)</span> の初期値は <span class="math inline">\(v_0\)</span> で、任意の時間 <span class="math inline">\(t_L\)</span> が経過すると <span class="math inline">\(v_1\)</span> に到達します。そして、遷移開始時点から <span class="math inline">\(t_L\)</span> まで <span class="math inline">\(v_2\)</span> を積分したときの値 <span class="math inline">\(d\)</span> がパラメータ変更前後での位相差 <span class="math inline">\(d\)</span> と等しくなるようにします。以下は <span class="math inline">\(d\)</span> の式です。</p>
<p><span class="math display">\[
d = \mathrm{fmod}(p_1 + v_1 t_L f_s,\,1.0) - p_0
\]</span></p>
<p>言い換えると、上の図のオレンジで塗りつぶした領域の面積 <span class="math inline">\(d\)</span> が <span class="math inline">\(\mathrm{fmod}(p_1 + v_1 t_L f_s,\,1.0) - p_0\)</span> と等しくなるようにします。</p>
<p>以降では式の簡略化のために、遷移にかかる秒数 <span class="math inline">\(t_L\)</span> をサンプル数 <span class="math inline">\(n_L\)</span> に変換して使います。</p>
<p><span class="math display">\[
n_L = t_L f_s
\]</span></p>
<h3 id="設計">設計</h3>
<p><span class="math inline">\(v_2\)</span> は時点 <span class="math inline">\(\dfrac{n_L}{2}\)</span> に速度 <span class="math inline">\(h\)</span> の中間点を置いて、 <span class="math inline">\(v_0, h, v_1\)</span> を順につないだ直線を使います。以下は中間点を使う <span class="math inline">\(v_2\)</span> の図です。</p>
<figure>
<img src="img/VelocityAreaImplementationsvg.svg" alt="Plot of v2 function which is implemented later in this document." style="padding-bottom: 12px;"/>
</figure>
<p>以降では式の簡略化のために <span class="math inline">\(m = \dfrac{n_L}{2}\)</span> とします。</p>
<p>以下は中間点を使う曲線 <span class="math inline">\(v_2\)</span> の式です。</p>
<p><span class="math display">\[
\begin{aligned}
v_2(n) &amp;= \begin{cases}
  v_0 + \dfrac{n}{m} (h - v_0)   &amp; \text{if} \enspace n &lt; m,\\\\
  h + \dfrac{n - m}{m} (v_1 - h) &amp; \text{if} \enspace n \geq m.\\
\end{cases}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(h\)</span> の計算式を求めます。</p>
<p><span class="math display">\[
\begin{aligned}
\int_{0}^{t_L} v_2(t)\ dt
&amp;= \int_{0}^{m} v_2(n)\ dn + \int_{m}^{n_L} v_2(n)\ dn\\
&amp;= \frac{(v_0 + h)m}{2} + \frac{(h + v_1)m}{2} \\
&amp;= d \\
\end{aligned}
\]</span></p>
<p><span class="math inline">\(h\)</span> について解きます。</p>
<p><span class="math display">\[
h = \frac{d}{m} - \frac{v_0 + v_1}{2}
\]</span></p>
<p>Python 3 で実装して動作確認します。以下のコードを実行すると同期間隔が変更された時点から 1 秒後までの位相をレンダリングします。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>fs <span class="op">=</span> <span class="dv">48000</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>tempo <span class="op">=</span> <span class="dv">120</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>sync0 <span class="op">=</span> <span class="fl">0.25</span> <span class="co"># 式中の S_0 。</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>sync1 <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># 式中の S_1 。</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>duration <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>nFrame <span class="op">=</span> <span class="bu">int</span>(fs <span class="op">*</span> duration)</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>p0 <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>p1 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>nLfo <span class="op">=</span> <span class="fl">0.1</span> <span class="op">*</span> fs <span class="co"># 式中の n_L 。</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>mid <span class="op">=</span> nLfo <span class="op">/</span> <span class="dv">2</span>  <span class="co"># 式中の m 。</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a>v0 <span class="op">=</span> tempo <span class="op">/</span> (fs <span class="op">*</span> sync0 <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb1-19"><a href="#cb1-19"></a>v1 <span class="op">=</span> tempo <span class="op">/</span> (fs <span class="op">*</span> sync1 <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>distance <span class="op">=</span> p1 <span class="op">+</span> v1 <span class="op">*</span> nLfo <span class="op">-</span> p0          <span class="co"># 式中の d 。</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>height <span class="op">=</span> distance <span class="op">/</span> mid <span class="op">-</span> (v0 <span class="op">+</span> v1) <span class="op">/</span> <span class="dv">2</span> <span class="co"># 式中の h 。</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>velocity <span class="op">=</span> np.interp(np.arange(nFrame), [<span class="dv">0</span>, mid, nLfo, nFrame], [v0, height, v1, v1])</span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a>phase1 <span class="op">=</span> np.linspace(p1, p1 <span class="op">+</span> v1 <span class="op">*</span> nFrame, nFrame) <span class="op">%</span> <span class="dv">1</span> <span class="co"># 素朴なテンポシンクの位相。</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>phase2 <span class="op">=</span> (p0 <span class="op">+</span> velocity.cumsum()) <span class="op">%</span> <span class="dv">1</span>                  <span class="co"># 滑らかにした位相。</span></span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co"># プロットは省略。</span></span></code></pre></div>
<p>プロットを含むテストコードは以下のリンク先で読めます。 <code>sync0, sync1, p0, p1</code> の値を変えることで動作を確認できます。</p>
<ul>
<li><a href="https://github.com/ryukau/filter_notes/blob/master/lfo_temposync/model.py">滑らかなテンポシンクのテストコードを読む (github.com, Python 3)</a></li>
</ul>
<p>実行結果のプロットです。位相方向の 0.0 と 1.0 の間は滑らかにつながっています。滑らかに遷移させた位相が一時的に逆走しています。</p>
<figure>
<img src="img/PythonImplementation.svg" alt="Plot of naively tempo-synced phase and smoothed phase." style="padding-bottom: 12px;"/>
</figure>
<h3 id="逆走の補正">逆走の補正</h3>
<p>位相の逆走は <span class="math inline">\(h &lt; 0\)</span> のときに <span class="math inline">\(v_2\)</span> が負の値になるために起こります。以下は逆走が起きるときの <span class="math inline">\(v_2\)</span> を表した図です。</p>
<figure>
<img src="img/PhaseReversingV2.svg" alt="Plot of an example of v2 which causes reverse running of phase." style="padding-bottom: 12px;"/>
</figure>
<p>逆走を防ぐには <span class="math inline">\(d\)</span> の値を調節することが考えられます。 <span class="math inline">\(d\)</span> と <span class="math inline">\(h\)</span> の式を再掲します。</p>
<p><span class="math display">\[
\begin{aligned}
d &amp;= \mathrm{fmod}(p_1 + v_1 t_L,\,1.0) - p_0\\
h &amp;= \frac{d}{m} - \frac{v_0 + v_1}{2}\\
\end{aligned}
\]</span></p>
<p><span class="math inline">\(d\)</span> は範囲 <span class="math inline">\([0, 1)\)</span> の 2 つの位相の差です。位相は巻き戻しがあるので <span class="math inline">\(\dots,\,d - 2,\,d - 1,\,d,\,d + 1,\,d + 2,\,\dots\)</span> はすべて同じ距離を表していると考えることができます。よって適当な整数 <span class="math inline">\(k\)</span> を用意して <span class="math inline">\(h\)</span> の式を以下のように書き換えられます。</p>
<p><span class="math display">\[
h = \frac{d + k}{m} - \frac{v_0 + v_1}{2}
\]</span></p>
<p><span class="math inline">\(h \geq 0\)</span> の条件をあてはめて <span class="math inline">\(k\)</span> について解きます。</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp;\leq \frac{d + k}{m} - \frac{v_0 + v_1}{2}\\
k &amp;\geq \frac{v_0 + v_1}{2}m - d\\
\end{aligned}
\]</span></p>
<p><span class="math inline">\(k\)</span> について解いた不等式の右辺に天井関数を付け加えた値を逆走を補正する整数として使います。</p>
<p><span class="math display">\[
k = \left\lceil \frac{v_0 + v_1}{2}m - d \right\rceil
\]</span></p>
<p>設計の節で掲載した Python 3 のコードの一部を以下のように変更します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>k <span class="op">=</span> np.ceil((v0 <span class="op">+</span> v1) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> mid <span class="op">-</span> distance)</span>
<span id="cb2-2"><a href="#cb2-2"></a>height <span class="op">=</span> (distance <span class="op">+</span> k) <span class="op">/</span> mid <span class="op">-</span> (v0 <span class="op">+</span> v1) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>以下は変更後の実行結果の図です。逆走していないことが確認できます。</p>
<figure>
<img src="img/PythonImplementationFixed.svg" alt="Plot of smoothed phase without reverse run." style="padding-bottom: 12px;"/>
</figure>
<h2 id="実装">実装</h2>
<h3 id="経過拍数の外挿">経過拍数の外挿</h3>
<p>ここまではテンポ、同期間隔、経過拍数が 1 サンプルごとに更新されることを前提にしていました。しかしプラグインで実装するときは DSP 処理の 1 サイクルごとにパラメータが更新されます。このときサイクル内での経過拍数の変化について<a href="https://en.wikipedia.org/wiki/Extrapolation">外挿</a>を行う必要があります。</p>
<p>今回はテンポがサイクルの開始時点以外では変化しないことを前提とします。テンポが変化しないのであれば 1 サイクル内の経過拍数は直線を描くことが保証されるので簡単に外挿できます。</p>
<h3 id="状態遷移">状態遷移</h3>
<p>パラメータの変化も事前にわかっている前提で話を進めてきましたが、プラグインでは次にどのような値が入力されるかは分かりません。さらに初期化の時点では DAW からテンポの値が送られてこないことがあります。</p>
<p>パラメータの変化への対応は LFO に以下の 4 つの状態を持たせることで解決を図ります。</p>
<ul>
<li>非同期状態 (free)</li>
<li>定常状態 (steady)</li>
<li>減速状態 (decelerating)</li>
<li>加速状態 (accelerating)</li>
</ul>
<p>サイクルの開始時点で定常状態であれば位相の位置と速度を更新します。</p>
<p>非同期状態はホストの停止中に使うことを想定しています。停止中は経過拍数が増えないので位相の速度だけを更新します。</p>
<p>減速状態と加速状態はテンポや同期間隔の変更時に滑らかな遷移を行うための状態です。</p>
<p>以下は状態遷移の条件です。</p>
<ul>
<li>初期状態は非同期状態。</li>
<li>ホストの再生開始で定常状態に移行。</li>
<li>非同期状態でないときに以下の条件が満たされれば、減速状態に移行。
<ul>
<li>現サイクルと 1 サイクル前のテンポが等しくない。</li>
<li>現サイクルと 1 サイクル前の同期間隔が等しくない。</li>
<li>現サイクルよりも 1 サイクル前の経過拍数のほうが大きい。</li>
</ul></li>
<li>減速開始から <span class="math inline">\(m\)</span> サンプル経過したら、加速状態に移行。</li>
<li>加速開始から <span class="math inline">\(m\)</span> サンプル経過したら、定常状態に移行。</li>
<li>ホストの停止で非同期状態に移行。</li>
</ul>
<p>以下は状態遷移図です。図中の <span class="math inline">\(n\)</span> は状態遷移後からの経過サンプル数です。 <span class="math inline">\(n\)</span> は状態遷移のたびに 0 にリセットされます。</p>
<figure>
<img src="img/StateTransition.svg" alt="Image of LFO state transition diagram." style="padding-bottom: 12px;"/>
</figure>
<h3 id="計算式の再掲">計算式の再掲</h3>
<p>滑らかな遷移に使う計算式をまとめて再掲します。</p>
<ul>
<li><span class="math inline">\(T\)</span>: テンポ [beat/min]</li>
<li><span class="math inline">\(B\)</span>: 経過拍数 [beat]</li>
<li><span class="math inline">\(S\)</span>: 同期間隔 [beat]</li>
<li><span class="math inline">\(p\)</span>: 位相の位置</li>
<li><span class="math inline">\(v\)</span>: 位相の速度 (1 サンプルあたりの増加量)</li>
</ul>
<p>下付き文字の <span class="math inline">\(_0\)</span> はパラメータ変更前の値、 <span class="math inline">\(_1\)</span> はパラメータ変更後の値を表しています。</p>
<p><span class="math display">\[
\begin{aligned}
p_0 &amp;= \frac{\mathrm{fmod}(B, S_0)}{S_0}, &amp;&amp; p_1 = \frac{\mathrm{fmod}(B, S_1)}{S_1},\\
v_0 &amp;= \frac{T_0}{60 f_s S_0}, &amp;&amp; v_1 = \frac{T_1}{60 f_s S_1}.\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(t_L\)</span>: 遷移にかかる秒数</li>
<li><span class="math inline">\(n_L\)</span>: 遷移にかかるサンプル数</li>
<li><span class="math inline">\(m\)</span>: 遷移開始から中間点に到達するまでのサンプル数</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
n_L = t_L f_s, &amp;&amp; m = \frac{n_L}{2}.\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(d\)</span>: パラメータ変更前後での位相差</li>
<li><span class="math inline">\(k\)</span>: 逆走を補正する巻き戻しの回数</li>
<li><span class="math inline">\(h\)</span>: 中間点での位相の速度</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
d &amp;= \mathrm{fmod}(p_1 + v_1 n_L,\,1.0) - p_0\\
k &amp;= \left\lceil \frac{v_0 + v_1}{2}m - d \right\rceil\\
h &amp;= \frac{d + k}{m} - \frac{v_0 + v_1}{2}\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(v_2\)</span>: 遷移時の位相の速度を表す曲線</li>
<li><span class="math inline">\(n\)</span>: 減速状態に移行してからの経過サンプル数</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
v_2(n) &amp;= \begin{cases}
  v_0 + \dfrac{n}{m} (h - v_0)   &amp; \text{if} \enspace n &lt; m,\\\\
  h + \dfrac{n - m}{m} (v_1 - h) &amp; \text{if} \enspace n \geq m.\\
\end{cases}
\end{aligned}
\]</span></p>
<h3 id="c-での実装">C++ での実装</h3>
<p>実装します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Sample&gt; <span class="kw">class</span> TempoSynchronizer {</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">private</span>:</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="kw">enum</span> <span class="kw">class</span> State { free, steady, decelerating, accelerating };</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>  State state = State::free;</span>
<span id="cb3-8"><a href="#cb3-8"></a>  Sample v1 = <span class="dv">0</span>;</span>
<span id="cb3-9"><a href="#cb3-9"></a>  Sample p1 = <span class="dv">0</span>;</span>
<span id="cb3-10"><a href="#cb3-10"></a>  Sample v2 = <span class="dv">0</span>;</span>
<span id="cb3-11"><a href="#cb3-11"></a>  Sample p2 = <span class="dv">0</span>;</span>
<span id="cb3-12"><a href="#cb3-12"></a>  Sample lastTempo = <span class="dv">0</span>;</span>
<span id="cb3-13"><a href="#cb3-13"></a>  Sample lastSync = <span class="dv">0</span>;</span>
<span id="cb3-14"><a href="#cb3-14"></a>  Sample lastElapsedBeats = <span class="dv">0</span>;</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>  Sample midTime = <span class="dv">0</span>; <span class="co">// In samples.</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  Sample midVelocity = <span class="dv">0</span>;</span>
<span id="cb3-18"><a href="#cb3-18"></a>  Sample counter = <span class="dv">0</span>;</span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a>  <span class="kw">inline</span> <span class="dt">void</span> setLastValues(Sample tempo, Sample sync, Sample elapsedBeats)</span>
<span id="cb3-21"><a href="#cb3-21"></a>  {</span>
<span id="cb3-22"><a href="#cb3-22"></a>    lastTempo = tempo;</span>
<span id="cb3-23"><a href="#cb3-23"></a>    lastSync = sync;</span>
<span id="cb3-24"><a href="#cb3-24"></a>    lastElapsedBeats = elapsedBeats;</span>
<span id="cb3-25"><a href="#cb3-25"></a>  }</span>
<span id="cb3-26"><a href="#cb3-26"></a></span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="kw">inline</span> Sample wrap(Sample value) { <span class="cf">return</span> value - <span class="bu">std::</span>floor(value); }</span>
<span id="cb3-28"><a href="#cb3-28"></a></span>
<span id="cb3-29"><a href="#cb3-29"></a><span class="kw">public</span>:</span>
<span id="cb3-30"><a href="#cb3-30"></a>  <span class="co">// DAW が停止中かつシンセの LFO がノートオンごとにリセットされるときだけ使用する。</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>  <span class="dt">void</span> reset()</span>
<span id="cb3-32"><a href="#cb3-32"></a>  {</span>
<span id="cb3-33"><a href="#cb3-33"></a>    p1 = <span class="dv">0</span>;</span>
<span id="cb3-34"><a href="#cb3-34"></a>    p2 = <span class="dv">0</span>;</span>
<span id="cb3-35"><a href="#cb3-35"></a>  }</span>
<span id="cb3-36"><a href="#cb3-36"></a></span>
<span id="cb3-37"><a href="#cb3-37"></a>  <span class="dt">void</span> reset(Sample sampleRate, Sample tempo, Sample sync)</span>
<span id="cb3-38"><a href="#cb3-38"></a>  {</span>
<span id="cb3-39"><a href="#cb3-39"></a>    v1 = <span class="bu">std::</span>fabs(sync) &lt;= <span class="bu">std::</span>numeric_limits&lt;Sample&gt;::min()</span>
<span id="cb3-40"><a href="#cb3-40"></a>      ? <span class="dv">0</span></span>
<span id="cb3-41"><a href="#cb3-41"></a>      : tempo / (Sample(<span class="dv">60</span>) * sampleRate * sync);</span>
<span id="cb3-42"><a href="#cb3-42"></a>    p1 = <span class="dv">0</span>;</span>
<span id="cb3-43"><a href="#cb3-43"></a>    v2 = v1;</span>
<span id="cb3-44"><a href="#cb3-44"></a>    p2 = <span class="dv">0</span>;</span>
<span id="cb3-45"><a href="#cb3-45"></a>    lastTempo = tempo;</span>
<span id="cb3-46"><a href="#cb3-46"></a>    lastSync = sync;</span>
<span id="cb3-47"><a href="#cb3-47"></a>  }</span>
<span id="cb3-48"><a href="#cb3-48"></a></span>
<span id="cb3-49"><a href="#cb3-49"></a>  <span class="co">// 各 DSP サイクルの開始時に必ず呼び出すこと。</span></span>
<span id="cb3-50"><a href="#cb3-50"></a>  <span class="dt">void</span></span>
<span id="cb3-51"><a href="#cb3-51"></a>  prepare(Sample sampleRate, Sample tempo, Sample sync, Sample elapsedBeats, <span class="dt">bool</span> isFree)</span>
<span id="cb3-52"><a href="#cb3-52"></a>  {</span>
<span id="cb3-53"><a href="#cb3-53"></a>    <span class="cf">if</span> (<span class="bu">std::</span>fabs(sync) &lt;= <span class="bu">std::</span>numeric_limits&lt;Sample&gt;::min()) {</span>
<span id="cb3-54"><a href="#cb3-54"></a>      v1 = <span class="dv">0</span>;</span>
<span id="cb3-55"><a href="#cb3-55"></a>      setLastValues(tempo, sync, elapsedBeats);</span>
<span id="cb3-56"><a href="#cb3-56"></a>      <span class="cf">return</span>;</span>
<span id="cb3-57"><a href="#cb3-57"></a>    }</span>
<span id="cb3-58"><a href="#cb3-58"></a></span>
<span id="cb3-59"><a href="#cb3-59"></a>    v1 = tempo / (Sample(<span class="dv">60</span>) * sampleRate * sync);</span>
<span id="cb3-60"><a href="#cb3-60"></a></span>
<span id="cb3-61"><a href="#cb3-61"></a>    <span class="cf">if</span> (isFree) state = State::free;</span>
<span id="cb3-62"><a href="#cb3-62"></a>    <span class="cf">if</span> (state == State::free) {</span>
<span id="cb3-63"><a href="#cb3-63"></a>      <span class="cf">if</span> (!isFree) state = State::steady;</span>
<span id="cb3-64"><a href="#cb3-64"></a>      setLastValues(tempo, sync, elapsedBeats);</span>
<span id="cb3-65"><a href="#cb3-65"></a>      <span class="cf">return</span>;</span>
<span id="cb3-66"><a href="#cb3-66"></a>    }</span>
<span id="cb3-67"><a href="#cb3-67"></a></span>
<span id="cb3-68"><a href="#cb3-68"></a>    <span class="kw">auto</span> p0 = p1;</span>
<span id="cb3-69"><a href="#cb3-69"></a>    p1 = wrap(elapsedBeats / sync);</span>
<span id="cb3-70"><a href="#cb3-70"></a></span>
<span id="cb3-71"><a href="#cb3-71"></a>    <span class="cf">if</span> (lastTempo != tempo || lastSync != sync || lastElapsedBeats &gt; elapsedBeats) {</span>
<span id="cb3-72"><a href="#cb3-72"></a>      <span class="cf">if</span> (<span class="bu">std::</span>fabs(lastSync) &lt;= <span class="bu">std::</span>numeric_limits&lt;Sample&gt;::min()) {</span>
<span id="cb3-73"><a href="#cb3-73"></a>        v2 = <span class="dv">0</span>;</span>
<span id="cb3-74"><a href="#cb3-74"></a>        p2 = p1;</span>
<span id="cb3-75"><a href="#cb3-75"></a>      } <span class="cf">else</span> <span class="cf">if</span> (lastElapsedBeats &gt; elapsedBeats) {</span>
<span id="cb3-76"><a href="#cb3-76"></a>        v2 = lastTempo / (Sample(<span class="dv">60</span>) * sampleRate * lastSync);</span>
<span id="cb3-77"><a href="#cb3-77"></a>        p2 = p0;</span>
<span id="cb3-78"><a href="#cb3-78"></a>      } <span class="cf">else</span> {</span>
<span id="cb3-79"><a href="#cb3-79"></a>        v2 = lastTempo / (Sample(<span class="dv">60</span>) * sampleRate * lastSync);</span>
<span id="cb3-80"><a href="#cb3-80"></a>        <span class="cf">if</span> (state == State::steady) p2 = wrap(elapsedBeats / lastSync);</span>
<span id="cb3-81"><a href="#cb3-81"></a>      }</span>
<span id="cb3-82"><a href="#cb3-82"></a></span>
<span id="cb3-83"><a href="#cb3-83"></a>      state = State::decelerating;</span>
<span id="cb3-84"><a href="#cb3-84"></a></span>
<span id="cb3-85"><a href="#cb3-85"></a>      midTime = Sample(<span class="fl">0.05</span>) * sampleRate; <span class="co">// 遷移時間 0.1 秒。中間点は遷移時間の半分。</span></span>
<span id="cb3-86"><a href="#cb3-86"></a>      <span class="kw">auto</span> distance = wrap(p1 + Sample(<span class="dv">2</span>) * v1 * midTime - p2);</span>
<span id="cb3-87"><a href="#cb3-87"></a>      <span class="kw">auto</span> k = <span class="bu">std::</span>ceil((v1 + v2) * Sample(<span class="fl">0.5</span>) * midTime - distance);</span>
<span id="cb3-88"><a href="#cb3-88"></a>      midVelocity = (distance + k) / midTime - (v1 + v2) * Sample(<span class="fl">0.5</span>);</span>
<span id="cb3-89"><a href="#cb3-89"></a></span>
<span id="cb3-90"><a href="#cb3-90"></a>      counter = <span class="dv">0</span>;</span>
<span id="cb3-91"><a href="#cb3-91"></a>    }</span>
<span id="cb3-92"><a href="#cb3-92"></a></span>
<span id="cb3-93"><a href="#cb3-93"></a>    setLastValues(tempo, sync, elapsedBeats);</span>
<span id="cb3-94"><a href="#cb3-94"></a>  }</span>
<span id="cb3-95"><a href="#cb3-95"></a></span>
<span id="cb3-96"><a href="#cb3-96"></a>  Sample process()</span>
<span id="cb3-97"><a href="#cb3-97"></a>  {</span>
<span id="cb3-98"><a href="#cb3-98"></a>    Sample outPhase;</span>
<span id="cb3-99"><a href="#cb3-99"></a>    <span class="cf">switch</span> (state) {</span>
<span id="cb3-100"><a href="#cb3-100"></a>      <span class="cf">default</span>:</span>
<span id="cb3-101"><a href="#cb3-101"></a>      <span class="cf">case</span> State::free:</span>
<span id="cb3-102"><a href="#cb3-102"></a>      <span class="cf">case</span> State::steady: {</span>
<span id="cb3-103"><a href="#cb3-103"></a>        outPhase = p1;</span>
<span id="cb3-104"><a href="#cb3-104"></a>        p1 = wrap(p1 + v1);</span>
<span id="cb3-105"><a href="#cb3-105"></a>      } <span class="cf">break</span>;</span>
<span id="cb3-106"><a href="#cb3-106"></a></span>
<span id="cb3-107"><a href="#cb3-107"></a>      <span class="cf">case</span> State::decelerating: {</span>
<span id="cb3-108"><a href="#cb3-108"></a>        outPhase = p2;</span>
<span id="cb3-109"><a href="#cb3-109"></a>        p2 = wrap(p2 + v2 + (midVelocity - v2) * counter / midTime);</span>
<span id="cb3-110"><a href="#cb3-110"></a>        <span class="cf">if</span> (++counter &gt;= midTime) {</span>
<span id="cb3-111"><a href="#cb3-111"></a>          state = State::accelerating;</span>
<span id="cb3-112"><a href="#cb3-112"></a>          counter = <span class="dv">0</span>;</span>
<span id="cb3-113"><a href="#cb3-113"></a>        }</span>
<span id="cb3-114"><a href="#cb3-114"></a>      } <span class="cf">break</span>;</span>
<span id="cb3-115"><a href="#cb3-115"></a></span>
<span id="cb3-116"><a href="#cb3-116"></a>      <span class="cf">case</span> State::accelerating: {</span>
<span id="cb3-117"><a href="#cb3-117"></a>        outPhase = p2;</span>
<span id="cb3-118"><a href="#cb3-118"></a>        p2 = wrap(p2 + midVelocity + (v1 - midVelocity) * counter / midTime);</span>
<span id="cb3-119"><a href="#cb3-119"></a>        <span class="cf">if</span> (++counter &gt;= midTime) {</span>
<span id="cb3-120"><a href="#cb3-120"></a>          state = State::steady;</span>
<span id="cb3-121"><a href="#cb3-121"></a>          p1 = p2;</span>
<span id="cb3-122"><a href="#cb3-122"></a>        }</span>
<span id="cb3-123"><a href="#cb3-123"></a>      } <span class="cf">break</span>;</span>
<span id="cb3-124"><a href="#cb3-124"></a>    }</span>
<span id="cb3-125"><a href="#cb3-125"></a>    <span class="cf">return</span> outPhase;</span>
<span id="cb3-126"><a href="#cb3-126"></a>  }</span>
<span id="cb3-127"><a href="#cb3-127"></a>};</span>
<span id="cb3-128"><a href="#cb3-128"></a></span>
<span id="cb3-129"><a href="#cb3-129"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb3-130"><a href="#cb3-130"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-131"><a href="#cb3-131"></a></span>
<span id="cb3-132"><a href="#cb3-132"></a><span class="dt">int</span> main()</span>
<span id="cb3-133"><a href="#cb3-133"></a>{</span>
<span id="cb3-134"><a href="#cb3-134"></a>  <span class="dt">float</span> sampleRate = <span class="fl">48000.0</span><span class="bu">f</span>;</span>
<span id="cb3-135"><a href="#cb3-135"></a>  <span class="dt">float</span> tempo = <span class="fl">120.0</span><span class="bu">f</span>;</span>
<span id="cb3-136"><a href="#cb3-136"></a>  <span class="dt">float</span> sync = <span class="fl">0.25</span><span class="bu">f</span>;</span>
<span id="cb3-137"><a href="#cb3-137"></a>  <span class="dt">float</span> elapsedBeats = <span class="fl">0.0</span><span class="bu">f</span>;</span>
<span id="cb3-138"><a href="#cb3-138"></a></span>
<span id="cb3-139"><a href="#cb3-139"></a>  <span class="bu">std::</span>array&lt;<span class="dt">float</span>, <span class="dv">2048</span>&gt; buffer{};</span>
<span id="cb3-140"><a href="#cb3-140"></a></span>
<span id="cb3-141"><a href="#cb3-141"></a>  <span class="co">// TempoSynchronizer の使用例。</span></span>
<span id="cb3-142"><a href="#cb3-142"></a>  TempoSynchronizer&lt;<span class="dt">float</span>&gt; lfo;</span>
<span id="cb3-143"><a href="#cb3-143"></a></span>
<span id="cb3-144"><a href="#cb3-144"></a>  <span class="cf">for</span> (<span class="dt">size_t</span> idx = <span class="dv">0</span>; idx &lt; buffer.size();) {</span>
<span id="cb3-145"><a href="#cb3-145"></a>    lfo.prepare(sampleRate, tempo, sync, elapsedBeats, <span class="kw">false</span>);</span>
<span id="cb3-146"><a href="#cb3-146"></a></span>
<span id="cb3-147"><a href="#cb3-147"></a>    <span class="kw">auto</span> beatsDelta = tempo / (<span class="fl">60.0</span><span class="bu">f</span> * sampleRate);</span>
<span id="cb3-148"><a href="#cb3-148"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; <span class="dv">512</span>; ++j) {</span>
<span id="cb3-149"><a href="#cb3-149"></a>      <span class="cf">if</span> (idx &gt;= buffer.size()) <span class="cf">break</span>;</span>
<span id="cb3-150"><a href="#cb3-150"></a>      buffer[idx++] = lfo.process();</span>
<span id="cb3-151"><a href="#cb3-151"></a>      elapsedBeats += beatsDelta;</span>
<span id="cb3-152"><a href="#cb3-152"></a></span>
<span id="cb3-153"><a href="#cb3-153"></a>      <span class="bu">std::</span>cout &lt;&lt; idx - <span class="dv">1</span> &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; buffer[idx - <span class="dv">1</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb3-154"><a href="#cb3-154"></a>    }</span>
<span id="cb3-155"><a href="#cb3-155"></a>  }</span>
<span id="cb3-156"><a href="#cb3-156"></a></span>
<span id="cb3-157"><a href="#cb3-157"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-158"><a href="#cb3-158"></a>}</span></code></pre></div>
<p>以下のリンク先により詳細なテストを掲載しています。</p>
<ul>
<li><a href="https://github.com/ryukau/filter_notes/blob/master/lfo_temposync/cpp/bench/bench.cpp">C++ 実装の詳細なテストコードを読む (github.com)</a></li>
</ul>
<h2 id="音のサンプル">音のサンプル</h2>
<h3 id="同期間隔の変更-1">同期間隔の変更</h3>
<p>素朴なテンポシンクでは 1 秒の時点でポップノイズが聞こえます。滑らかなテンポシンクではポップノイズは聞き取れません。</p>
<figure>
<figcaption>
素朴にテンポシンクされた LFO による振幅変調
</figcaption>
<audio controls>
<source src="snd/NaiveSyncChange.wav" type="audio/wav">
</audio>
</figure>
<figure>
<figcaption>
滑らかにテンポシンクされた LFO による振幅変調
</figcaption>
<audio controls>
<source src="snd/amout_Sync.wav" type="audio/wav">
</audio>
</figure>
<h3 id="テンポの変更-1">テンポの変更</h3>
<p>素朴なテンポシンク、滑らかなテンポシンクともにポップノイズは聞き取れません。滑らかなテンポシンクは位相の進み方を変えることによる癖がついているので、用途によっては素朴なテンポシンクのほうが適しているかもしれません。</p>
<figure>
<figcaption>
素朴にテンポシンクされた LFO による振幅変調
</figcaption>
<audio controls>
<source src="snd/NaiveTempoChange.wav" type="audio/wav">
</audio>
</figure>
<figure>
<figcaption>
滑らかにテンポシンクされた LFO による振幅変調
</figcaption>
<audio controls>
<source src="snd/amout_Tempo.wav" type="audio/wav">
</audio>
</figure>
<h2 id="その他">その他</h2>
<h3 id="位相の計算式の変形">位相の計算式の変形</h3>
<p>経過拍数 <span class="math inline">\(B\)</span> と同期間隔 <span class="math inline">\(S\)</span> は正の実数なので、位相 <span class="math inline">\(p\)</span> の計算式は以下のように変形できます。</p>
<p><span class="math display">\[
p = \frac{B}{S} - \left\lfloor \frac{B}{S} \right\rfloor
\]</span></p>
<p>C++ の実装では <code>std::fmod</code> よりも <code>std::floor</code> のほうが高速なので、この変形が役に立ちます。</p>
<h3 id="テンポシンクに必要な情報の取得">テンポシンクに必要な情報の取得</h3>
<p>VST 3 では <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessContext.html"><code>ProcessContext</code></a> から、テンポ、再生開始から経過した拍数、再生中かどうかの情報が提供されます。</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessContext.html">VST 3 Interfaces: ProcessContext Struct Reference</a></li>
</ul>
<p>LV2 では <a href="http://lv2plug.in/ns/ext/time">Time</a> から必要な情報が提供されます。テンポは <code>beatsPerMinute</code> 、経過拍数は <code>beat</code> です。メトロノームプラグインの例である <a href="https://gitlab.com/lv2/lv2/-/blob/master/plugins/eg-metro.lv2/metro.c"><code>metro.c</code></a> に使い方が書いてあります。</p>
<ul>
<li><a href="https://lv2plug.in/book/#_metronome">Programming LV2 Plugins</a></li>
<li><a href="https://gitlab.com/lv2/lv2/-/blob/master/plugins/eg-metro.lv2/metro.c">plugins/eg-metro.lv2/metro.c · master · LV2 / lv2 · GitLab</a></li>
</ul>
<h2 id="変更点">変更点</h2>
<ul>
<li>2021/05/09
<ul>
<li>C++ の実装で、減速中あるいは加速中にパラメータの変更によって減速状態に戻ったときにポップノイズが出る問題を修正。</li>
<li>遷移にかかる時間を任意に変更できるように <span class="math inline">\(d\)</span> を変更。</li>
<li>経過拍数の巻き戻しに関する状態遷移を追加。</li>
<li>図と文章の整理と追加。</li>
</ul></li>
</ul>
<footer>
<a href="../index.html">インデックスに戻る</a>
</footer>
</body>

</html>
