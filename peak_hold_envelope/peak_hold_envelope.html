<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja" >

<head>
<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="dcterms.date" content="2021-01-06" />
<title>hold_envelope</title>

<!-- KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
onload="renderMathInElement(document.body);"></script>

<style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #666666;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #666666;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; text-decoration: underline; } /* Alert */
code span.an { color: #666666; font-style: italic; } /* Annotation */
code span.at { color: #906000; } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #000000; font-weight: bold; } /* ControlFlow */
code span.ch { color: #b000b0; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008800; } /* Comment */
code span.cv { color: #008800; } /* CommentVar */
code span.do { color: #008800; } /* Documentation */
code span.dt { color: #906000; } /* DataType */
code span.dv { color: #0000ff; } /* DecVal */
code span.er { color: #ffffff; background-color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000ff; } /* Float */
code span.im { color: #000000; font-weight: bold; } /* Import */
code span.in { color: #666666; } /* Information */
code span.kw { color: #000000; font-weight: bold; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #000000; } /* Other */
code span.pp { color: #000000; font-weight: bold; } /* Preprocessor */
code span.sc { color: #b000b0; } /* SpecialChar */
code span.ss { color: #b000b0; } /* SpecialString */
code span.st { color: #b000b0; } /* String */
code span.va { color: #000088; } /* Variable */
code span.vs { color: #b000b0; } /* VerbatimString */
code span.wa { background-color: #ffff00; font-weight: bold; font-style: italic; text-decoration: underline; } /* Warning */
</style>
<style>
body {
max-width: 704px;
margin: auto;
padding: 32px 8px;
}

img {
max-width: 100%;
}

video {
max-width: 100%;
}

kbd {
font-family: inherit;
border-style: solid;
border-width: 1px 2px 2px 1px;
border-radius: 2px;
padding: 4px;
margin: 2px;
line-height: calc(1em + 16px);
}

a {
text-decoration: none;
}

h2 {
border-left: solid 32px #000000;
padding-left: 24px;
}

h3 {
border-left: solid 20px #404040;
padding-left: 16px;
}

h4 {
border-left: solid 12px #606060;
padding-left: 8px;
}

h5 {
border-left: solid 4px #808080;
padding-left: 4px;
}

h6 {
border-left: solid 2px #a0a0a0;
padding-left: 2px;
}

table {
border-spacing: 0px;
border-collapse: separate;
border-left: 1px solid #888888;
border-right: 1px solid #888888;
border-top: 1px solid #888888;
border-bottom: hidden;
}

tr:nth-child(odd) {
background: #eeeeee;
}

tr:nth-child(even) {
background: #ffffff;
}

th {
height: 2em;
padding: 4px 1em 4px 1em;
background: #ffffff;
border-bottom: 1px solid #888888;
}

th:not(:first-child) {
border-left: 1px solid #888888;
}

td {
height: 1.5em;
padding: 4px 1em 4px 1em;
border-bottom: 1px solid #888888;
}

td:not(:first-child) {
border-left: 1px solid #888888;
}

dl {
padding-left: 2em;
}

dt {
font-weight: bold;
border-bottom: 1px dashed #000000;
margin-top: 2em;
}

dd {
border-left: 1px dotted #000000;
margin-left: 1em;
padding-left: 1em;
}

audio {
vertical-align: middle;
}

label {
vertical-align: middle;
}

:not(.sourceCode)>pre {
overflow: auto;
border: 1px solid #888888;
padding: 8px;
}

div.sourceCode {
overflow: auto;
border: 1px solid #888888;
padding: 8px;
}

pre>code.sourceCode>span>a:first-child::before {
border-right: 1px solid #888888;
padding-right: 1em;
margin-right: 1em;
text-decoration: none;
}

:not(pre)>code {
color: #163eac;
}

li {
margin: 8px;
}

summary:hover {
background-color: #eeeeee;
}

header {
border-bottom: 1px gray solid;
padding: 0.5em;
margin-bottom: 1em;
}

footer {
border-top: 1px gray solid;
padding: 0.5em;
margin-top: 1em;
}


canvas {
/* image-rendering: pixelated; */
display: inline-block;
border-style: solid;
border-width: 1px;
border-color: #627f84;
}

.controlBlock {
display: inline-block;
width: 450px;
text-align: left;
vertical-align: top;
margin-left: 4px;
}

input[type="button"] {
background-color: #ffffff;
border: 2px solid #aaaaaa;
font-size: 16px;
height: 32px;
}

input[type="button"]:hover {
background-color: #ffffff;
border: 2px solid #aaccff;
}

div.numberInput {
display: block;
white-space: nowrap;
}

div.numberInput:hover {
background-color: #e0ecff;
}

.numberInputLabel {
/* max 12 letter  */
display: inline-block;
margin: 0 8px 0 8px;
text-align: left;
vertical-align: middle;
width: 100px;

font-size: 10pt;
font-family: 'Courier New', Courier, monospace;
}

.numberInputNumber {
display: inline-block;
vertical-align: middle;
width: 120px;
}

.numberInputRange {
display: inline-block;
vertical-align: middle;
width: 160px;
}

.pullDownMenu {
display: inline-block;
text-align: center;
}

.pullDownMenu:hover {
background-color: #e0ecff;
}

select {
background-color: #ffffff;
border: 2px solid #aaaaaa;
height: 24px;
vertical-align: middle;
font-size: 12px;
}

select:hover {
background-color: #ffffff;
border: 2px solid #aaccff;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>

<body>
<header>
<p>
何かあれば <a href="https://github.com/ryukau/filter_notes">GitHub のリポジトリ</a>に issue を作るか ryukau@gmail.com までお気軽にどうぞ。
</p>
<hr>
<a href="../index.html">インデックスに戻る</a>
<p>
Update: 2021-01-06
</p>
<details>
<summary translate="yes">Table of Contents</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#ピークホールドによるエンベロープ">ピークホールドによるエンベロープ</a><ul>
<li><a href="#前向きホールド">前向きホールド</a></li>
<li><a href="#スムーシング">スムーシング</a></li>
<li><a href="#理想的なホールド">理想的なホールド</a><ul>
<li><a href="#realtime-implementation">リアルタイムで使えるアルゴリズム</a><ul>
<li><a href="#レシピ">レシピ</a></li>
</ul></li>
<li><a href="#テスト">テスト</a></li>
<li><a href="#c-による実装">C++ による実装</a></li>
</ul></li>
<li><a href="#その他">その他</a><ul>
<li><a href="#後ろ向きホールド">後ろ向きホールド</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
</details>
</header>
<h1 id="ピークホールドによるエンベロープ">ピークホールドによるエンベロープ</h1>
<p>音のリミッタで使うために、ピークホールドを使ったエンベロープの検出を実装します。</p>
<h2 id="前向きホールド">前向きホールド</h2>
<p>入力信号の絶対値を計算します。</p>
<figure>
<img src="img/input_signal.svg" alt="Plot of input signal and its absolute value." style="padding-bottom: 12px;"/>
</figure>
<p>絶対値を前から順に読み取って、そのときまでの最大値を出力します。これがもっとも単純な前向きホールドです。</p>
<figure>
<img src="img/simple_forward_peak_hold.svg" alt="Plot of simple forward peak hold." style="padding-bottom: 12px;"/>
</figure>
<p>しかし、単純な前向きホールドでは減衰するエンベロープをうまく検出できません。</p>
<figure>
<img src="img/simple_forward_peak_hold_of_decaying_signal.svg" alt="Plot of simple forward peak hold of decaying signal." style="padding-bottom: 12px;"/>
</figure>
<p>そこで、一定時間が経ったらホールドしていた最大値を忘れるようにします。この文章で前向きホールドと言うときは、最大値を忘れる実装を指すことにします。</p>
<figure>
<img src="img/forward_peak_hold_of_decaying_signal.svg" alt="Plot of forward peak hold." style="padding-bottom: 12px;"/>
</figure>
<p>Python 3 で実装します。この文章の Python 3 のコードは上から順にテキストファイルにコピペすると動きます。実行には <a href="https://www.scipy.org/">SciPy</a> 、 <a href="https://numpy.org/">NumPy</a> 、 <a href="https://matplotlib.org/">matplotlib</a> が必要です。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">def</span> peakHoldForward(sig, holdtime, reset<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">    holdtime の単位はサンプル数。</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">    最後に最大値が更新されてから holdtime サンプル後に hold の値をリセットする。</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    out <span class="op">=</span> np.empty(<span class="bu">len</span>(sig))</span>
<span id="cb1-10"><a href="#cb1-10"></a>    hold <span class="op">=</span> reset</span>
<span id="cb1-11"><a href="#cb1-11"></a>    counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(sig)):</span>
<span id="cb1-13"><a href="#cb1-13"></a>        <span class="cf">if</span> counter <span class="op">&gt;</span> <span class="dv">0</span>:  <span class="co"># 注意: 比較に &gt;= を使うとホールド時間が 1 サンプル延びる。</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>            counter <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>        <span class="cf">else</span>:</span>
<span id="cb1-16"><a href="#cb1-16"></a>            hold <span class="op">=</span> reset</span>
<span id="cb1-17"><a href="#cb1-17"></a>        <span class="cf">if</span> hold <span class="op">&lt;=</span> sig[i]:  <span class="co"># 注意: カウンタをリセットしたいので &lt;= で比較。</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>            hold <span class="op">=</span> sig[i]</span>
<span id="cb1-19"><a href="#cb1-19"></a>            counter <span class="op">=</span> holdtime</span>
<span id="cb1-20"><a href="#cb1-20"></a>        out[i] <span class="op">=</span> hold</span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="cf">return</span> out</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">0</span>)</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>sig <span class="op">=</span> rng.normal(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">256</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a>absed <span class="op">=</span> np.<span class="bu">abs</span>(sig)</span>
<span id="cb1-27"><a href="#cb1-27"></a>holdF <span class="op">=</span> peakHoldForward(absed, <span class="dv">32</span>, <span class="dv">0</span>)</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a>plt.plot(sig, label<span class="op">=</span><span class="st">&quot;Input&quot;</span>)</span>
<span id="cb1-30"><a href="#cb1-30"></a>plt.plot(absed, label<span class="op">=</span><span class="st">&quot;Absed&quot;</span>)</span>
<span id="cb1-31"><a href="#cb1-31"></a>plt.plot(holdF, label<span class="op">=</span><span class="st">&quot;Forward Hold&quot;</span>)</span>
<span id="cb1-32"><a href="#cb1-32"></a>plt.show()</span></code></pre></div>
<h2 id="スムーシング">スムーシング</h2>
<p>ある信号の絶対値をなだらかに包み込むような信号のことを、その信号のエンベロープと言います。しきい値やニーなどの特性を加えたエンベロープの逆数を入力信号に掛け合わせることで音量を制限するリミッタが作れます。</p>
<p>前向きホールドによるエンベロープをそのまま使うとホールド値を忘れるときにポップノイズが出てしまうので、フィルタを使ってスムーシングします。ここで使うフィルタは、一定時間同じ値が入力されると、その値に到達することが保証されているものとします。移動平均フィルタの重ね掛けや、 Bessel フィルタはこのような設計ができます。リミッタ向きのフィルタについては<a href="../s_curve_step_response_filter/s_curve_step_response_filter.html">「ステップ応答が S 字を描くフィルタ」</a>にまとめています。</p>
<p>以降では、以下のコードで設計した三角窓の FIR フィルタを使います。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> makeTriangleFir(delay):</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="co">&quot;&quot;&quot;delay は 2 より大きい整数。&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    fir <span class="op">=</span> np.interp(</span>
<span id="cb2-4"><a href="#cb2-4"></a>        np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, delay <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb2-5"><a href="#cb2-5"></a>        [<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>],</span>
<span id="cb2-6"><a href="#cb2-6"></a>        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb2-7"><a href="#cb2-7"></a>    )</span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="cf">return</span> fir <span class="op">/</span> np.<span class="bu">sum</span>(fir)</span></code></pre></div>
<p>前向きホールドの出力にフィルタをかけると立ち上がりと立ち下りが鈍るので、入力信号との間でピークの位置がずれます。以降ではホールドの出力にフィルタをかけた信号をエンベロープと呼びます。</p>
<figure>
<img src="img/smoothed_hold.svg" alt="Plot of smoothed hold." style="padding-bottom: 12px;"/>
</figure>
<p>そこで入力信号にディレイをかけてエンベロープとピークの位置をあわせます。実装によりますが、リミッタのレイテンシはこのディレイから来ています。</p>
<figure>
<img src="img/smoothed_hold_and_delayed_signal_arrow.svg" alt="Plot of smoothed hold and delayed signal." style="padding-bottom: 12px;"/>
</figure>
<p>ここで致命的な問題があります。上の図の赤い矢印で示した箇所などで、入力信号のピークがエンベロープからはみ出しています。このようなはみ出しが起こるエンベロープをリミッタで使うと音量が制限できません。</p>
<p>以下は、はみ出しが起こるパターンを示した図です。入力信号のピークはフィルタをかける前のエンベロープからは、はみ出しません。しかし、ディレイを加えた入力信号はフィルタをかけたエンベロープからはみ出すことがあります。</p>
<figure>
<img src="img/protruding_peak_fail.svg" alt="Image of a pattern which causes protruding peak." style="padding-bottom: 12px;"/>
</figure>
<p>はみ出しが起こるのは、ホールド中に入力された小さいピークを見逃しているからです。下の図のように、ホールド値を忘れるときに入力を振り返って見逃したピークをホールドしなおせば、はみ出しが防げそうです。</p>
<figure>
<img src="img/protruding_peak_desired.svg" alt="Image of desired envelope which eliminates protruding peak." style="padding-bottom: 12px;"/>
</figure>
<h2 id="理想的なホールド">理想的なホールド</h2>
<p>ホールド値より小さいピークを見逃さないためには、ホールド時間と同じ長さのバッファを用意して入力を覚えておく方法があります。出力にはバッファ内の最大値を使います。以下はこのアルゴリズムのコード例です。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">def</span> idealPeakHoldNaive(sig, holdtime: <span class="bu">int</span>):</span>
<span id="cb3-4"><a href="#cb3-4"></a>    out <span class="op">=</span> np.empty(<span class="bu">len</span>(sig))</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="bu">buffer</span> <span class="op">=</span> deque([<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(holdtime)])</span>
<span id="cb3-6"><a href="#cb3-6"></a>    counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(sig)):</span>
<span id="cb3-8"><a href="#cb3-8"></a>        <span class="bu">buffer</span>.append(<span class="bu">abs</span>(sig[i]))</span>
<span id="cb3-9"><a href="#cb3-9"></a>        <span class="bu">buffer</span>.popleft()</span>
<span id="cb3-10"><a href="#cb3-10"></a>        out[i] <span class="op">=</span> <span class="bu">max</span>(<span class="bu">buffer</span>)</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">return</span> out</span></code></pre></div>
<p>ここでは上のコードのアルゴリズムのことを理想的なホールドの素朴な実装と呼びます。素朴な実装の問題点は計算量です。上のコードの <code>out[i] = max(buffer)</code> は Python では 1 行で書けますが、計算量はバッファの長さに比例します。したがってホールド時間を長くすると計算が重たくなります。</p>
<h3 id="realtime-implementation">リアルタイムで使えるアルゴリズム</h3>
<p>計算量の問題を解決するために試行錯誤したところ、局所最大値をキューに保存することで高速に計算するアルゴリズムを思いつきました。</p>
<p>例として以下のような入力について考えます。図の赤い実線が理想的なホールドの出力です。赤い点線は出力値の候補を表しています。</p>
<figure>
<img src="img/ideal_hold_local_maximum.svg" alt="Plot of local maximum of ideal hold. 1st peak has the largest value. 2nd peak is the smallest. The value of 3rd peak is in between 1st and 2nd." style="padding-bottom: 12px;"/>
</figure>
<p>ここでピーク 2 は以下の条件が揃っているので出力に影響を及ぼしません。</p>
<ul>
<li>ピーク 2 はピーク 1 のホールド時間内に現れる。</li>
<li>ピーク 2 より後に、より値の大きいピーク 3 が現れる。</li>
<li>ピーク 3 もピーク 1 のホールド時間内に現れる。</li>
<li>ピーク 2 はピーク 1 とピーク 3 よりも小さい。</li>
</ul>
<p>言い換えると、ピーク 3 が入力されたときにホールド時間だけ入力を振り返って、ピーク 3 よりも小さい値を忘れてしまってもいいということです。</p>
<h4 id="レシピ">レシピ</h4>
<p>以下のメモリを確保します。</p>
<ul>
<li>ホールド時間 + 1 サンプルのディレイ。 0 で初期化。</li>
<li>ホールド時間のサンプル数と同じ長さのキュー。 0 で初期化。</li>
</ul>
<p>計算手順です。</p>
<ol type="1">
<li>キューの最後尾が入力サンプル <code>x0</code> 以上の値になるまで、キューの最後尾を繰り返し除去。</li>
<li><code>x0</code> をキューの後ろに追加。</li>
<li><code>x0</code> をディレイに入力。</li>
<li>もしディレイの出力とキューの先頭の値が等しければ、キューから値を取り出す。</li>
<li>キューに一つでも値が残っていれば、キューの先頭を出力。そうでなければ 0 を出力。</li>
</ol>
<p>上のレシピに沿った Python 3 による実装です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">def</span> idealPeakHoldFast(sig, holdTime):</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">    sig: 入力信号。</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">    holdTime: ホールド時間。単位はサンプル数。</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    out <span class="op">=</span> np.empty(<span class="bu">len</span>(sig))                     <span class="co"># 出力信号。</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="bu">buffer</span> <span class="op">=</span> deque([<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(holdTime)]) <span class="co"># ディレイのバッファ。</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    hold <span class="op">=</span> deque([])                             <span class="co"># ホールド値のキュー。</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(sig)):</span>
<span id="cb4-12"><a href="#cb4-12"></a>        x0 <span class="op">=</span> sig[i]</span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="cf">if</span> <span class="bu">len</span>(hold) <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># 手順 1</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>            idx <span class="op">=</span> <span class="bu">len</span>(hold) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>            <span class="cf">while</span> idx <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-17"><a href="#cb4-17"></a>                <span class="cf">if</span> hold[idx] <span class="op">&lt;</span> x0:</span>
<span id="cb4-18"><a href="#cb4-18"></a>                    hold.pop()</span>
<span id="cb4-19"><a href="#cb4-19"></a>                <span class="cf">else</span>:</span>
<span id="cb4-20"><a href="#cb4-20"></a>                    <span class="cf">break</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>                idx <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-22"><a href="#cb4-22"></a></span>
<span id="cb4-23"><a href="#cb4-23"></a>        hold.append(x0)   <span class="co"># 手順 2</span></span>
<span id="cb4-24"><a href="#cb4-24"></a></span>
<span id="cb4-25"><a href="#cb4-25"></a>        <span class="bu">buffer</span>.append(x0) <span class="co"># 手順 3</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>        delayOut <span class="op">=</span> <span class="bu">buffer</span>.popleft()</span>
<span id="cb4-27"><a href="#cb4-27"></a></span>
<span id="cb4-28"><a href="#cb4-28"></a>        <span class="cf">if</span> <span class="bu">len</span>(hold) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> delayOut <span class="op">==</span> hold[<span class="dv">0</span>]: <span class="co"># 手順 4</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>            hold.popleft()</span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a>        out[i] <span class="op">=</span> hold[<span class="dv">0</span>] <span class="cf">if</span> <span class="bu">len</span>(hold) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span> <span class="co"># 手順 5</span></span>
<span id="cb4-32"><a href="#cb4-32"></a></span>
<span id="cb4-33"><a href="#cb4-33"></a>    <span class="cf">return</span> out</span></code></pre></div>
<p>以下は理想的なホールドの出力です。高速な実装と理想的な実装の出力が一致しています。</p>
<figure>
<img src="img/ideal_hold.svg" alt="Plot of ideal hold envelope." style="padding-bottom: 12px;"/>
</figure>
<p>スムーシングした理想的なホールドの出力です。ディレイをかけた入力がエンベロープからはみ出していないことが確認できます。</p>
<figure>
<img src="img/smoothed_ideal_hold.svg" alt="Plot of smoothed hold envelope." style="padding-bottom: 12px;"/>
</figure>
<h3 id="テスト">テスト</h3>
<p>理想的なホールドを使えばはみ出しが起こらないことをテストします。</p>
<p>テスト用の入力として、ランダムにインパルスが散らばったノイズを作ります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">def</span> nextTime(rng, rate):</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">    ポアソン過程。</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">    もし単位時間当たり N 回のイベントが起こるなら `rate` を `1/N` に設定する。</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="cf">return</span> <span class="op">-</span>np.log(<span class="fl">1.0</span> <span class="op">-</span> rng.uniform(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="op">/</span> rate</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">def</span> pulseNoise(rng, rate, length):</span>
<span id="cb5-9"><a href="#cb5-9"></a>    out <span class="op">=</span> np.zeros(length)</span>
<span id="cb5-10"><a href="#cb5-10"></a>    time <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="cf">while</span> time <span class="op">&lt;</span> length:</span>
<span id="cb5-12"><a href="#cb5-12"></a>        time <span class="op">+=</span> nextTime(rng, rate)</span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a>        t1 <span class="op">=</span> <span class="bu">int</span>(time)</span>
<span id="cb5-15"><a href="#cb5-15"></a>        t2 <span class="op">=</span> t1 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>        amp <span class="op">=</span> rng.uniform(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a>        <span class="cf">if</span> t1 <span class="op">&lt;</span> length:</span>
<span id="cb5-18"><a href="#cb5-18"></a>            out[t1] <span class="op">=</span> amp <span class="op">*</span> (t2 <span class="op">-</span> time)</span>
<span id="cb5-19"><a href="#cb5-19"></a>        <span class="cf">if</span> t2 <span class="op">&lt;</span> length:</span>
<span id="cb5-20"><a href="#cb5-20"></a>            out[t2] <span class="op">=</span> amp <span class="op">*</span> (time <span class="op">-</span> t1)</span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="cf">return</span> out</span></code></pre></div>
<p>ポアソン過程の実装は Jeff Preshing さんによる以下の記事を参考にしました。</p>
<ul>
<li><a href="https://preshing.com/20111007/how-to-generate-random-timings-for-a-poisson-process/">How to Generate Random Timings for a Poisson Process</a></li>
</ul>
<p>以下はテストコードです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> multiprocessing <span class="im">import</span> Pool</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">def</span> verifyHoldEnvelope(sig, env, name):</span>
<span id="cb6-4"><a href="#cb6-4"></a>    condition <span class="op">=</span> (sig <span class="op">-</span> env) <span class="op">&gt;</span> <span class="dv">8</span> <span class="op">*</span> np.finfo(np.float64).eps</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="cf">if</span> np.<span class="bu">any</span>(condition):</span>
<span id="cb6-6"><a href="#cb6-6"></a>        idx <span class="op">=</span> np.where(condition)</span>
<span id="cb6-7"><a href="#cb6-7"></a>        diff <span class="op">=</span> np.take(sig, idx) <span class="op">-</span> np.take(env, idx)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Test failed: </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, diff, sep<span class="op">=</span><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">def</span> jobTestIdealHoldRandom(seed):</span>
<span id="cb6-11"><a href="#cb6-11"></a>    hold <span class="op">=</span> <span class="dv">32</span>   <span class="co"># ホールド時間 (サンプル数)</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    delay <span class="op">=</span> <span class="dv">32</span>  <span class="co"># フィルタの遅延 (サンプル数)</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    triangleFir <span class="op">=</span> makeTriangleFir(delay)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a>    rng <span class="op">=</span> np.random.default_rng(seed)</span>
<span id="cb6-16"><a href="#cb6-16"></a>    sig <span class="op">=</span> pulseNoise(rng, <span class="dv">1</span> <span class="op">/</span> <span class="dv">8</span>, <span class="dv">48000</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>    naive <span class="op">=</span> idealPeakHoldNaive(sig, hold)</span>
<span id="cb6-19"><a href="#cb6-19"></a>    fast <span class="op">=</span> idealPeakHoldFast(sig, hold)</span>
<span id="cb6-20"><a href="#cb6-20"></a></span>
<span id="cb6-21"><a href="#cb6-21"></a>    smoothedNaive <span class="op">=</span> signal.lfilter(triangleFir, <span class="dv">1</span>, naive)</span>
<span id="cb6-22"><a href="#cb6-22"></a>    smoothedFast <span class="op">=</span> signal.lfilter(triangleFir, <span class="dv">1</span>, fast)</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a>    delayed <span class="op">=</span> np.hstack((np.zeros(hold), sig[:<span class="op">-</span>hold]))</span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a>    verifyHoldEnvelope(delayed, smoothedNaive, <span class="ss">f&quot;Naive, </span><span class="sc">{</span>seed<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>delay<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-27"><a href="#cb6-27"></a>    verifyHoldEnvelope(delayed, smoothedFast, <span class="ss">f&quot;Fast, </span><span class="sc">{</span>seed<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>delay<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="kw">def</span> testIdealHoldRandom(nTest<span class="op">=</span><span class="dv">1024</span>):</span>
<span id="cb6-30"><a href="#cb6-30"></a>    <span class="cf">with</span> Pool() <span class="im">as</span> pool:</span>
<span id="cb6-31"><a href="#cb6-31"></a>        seeds <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nTest)]</span>
<span id="cb6-32"><a href="#cb6-32"></a>        idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>        <span class="cf">for</span> result <span class="kw">in</span> pool.imap_unordered(jobTestIdealHoldRandom, seeds):</span>
<span id="cb6-34"><a href="#cb6-34"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\r</span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss">&quot;</span>, end<span class="op">=</span><span class="st">&quot;&quot;</span>)  <span class="co"># 処理が終わったシード値を表示。</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>            idx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb6-38"><a href="#cb6-38"></a>    testIdealHoldRandom()</span></code></pre></div>
<p>フィルタの遅延はホールド時間以下の任意のサンプル数に設定できますが、値によっては誤差が増えます。上のコードでは誤差の上限を適当に <code>8 * np.finfo(np.float64).eps</code> としています。</p>
<p>はみ出しを検知したときは <code>Test failed: ...</code> を出力します。シード値 0 から 1023 まで今回実装した理想的なホールドをテストしたところ、はみ出しは検知されませんでした。</p>
<h3 id="c-による実装">C++ による実装</h3>
<p>以下のコードの <code>PeakHold</code> が理想的なホールドです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">// 整数サンプルのディレイ。</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Sample&gt; <span class="kw">class</span> Delay {</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">public</span>:</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="bu">std::</span>vector&lt;Sample&gt; buf;</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="dt">size_t</span> wptr = <span class="dv">0</span>;</span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="dt">size_t</span> rptr = <span class="dv">0</span>;</span>
<span id="cb7-12"><a href="#cb7-12"></a></span>
<span id="cb7-13"><a href="#cb7-13"></a>  Delay(<span class="dt">size_t</span> size = <span class="dv">65536</span>) : buf(size) {}</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>  <span class="dt">void</span> resize(<span class="dt">size_t</span> size)</span>
<span id="cb7-16"><a href="#cb7-16"></a>  {</span>
<span id="cb7-17"><a href="#cb7-17"></a>    buf.resize(size);</span>
<span id="cb7-18"><a href="#cb7-18"></a>    wptr = <span class="dv">0</span>;</span>
<span id="cb7-19"><a href="#cb7-19"></a>    rptr = <span class="dv">0</span>;</span>
<span id="cb7-20"><a href="#cb7-20"></a>  }</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a>  <span class="dt">void</span> reset() { <span class="bu">std::</span>fill(buf.begin(), buf.end(), Sample(<span class="dv">0</span>)); }</span>
<span id="cb7-23"><a href="#cb7-23"></a></span>
<span id="cb7-24"><a href="#cb7-24"></a>  <span class="dt">void</span> setFrames(<span class="dt">size_t</span> delayFrames)</span>
<span id="cb7-25"><a href="#cb7-25"></a>  {</span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="cf">if</span> (delayFrames &gt;= buf.size()) delayFrames = buf.size();</span>
<span id="cb7-27"><a href="#cb7-27"></a>    rptr = wptr - delayFrames;</span>
<span id="cb7-28"><a href="#cb7-28"></a>    <span class="cf">if</span> (rptr &gt;= buf.size()) rptr += buf.size(); <span class="co">// Unsigned overflow case.</span></span>
<span id="cb7-29"><a href="#cb7-29"></a>  }</span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a>  Sample process(Sample input)</span>
<span id="cb7-32"><a href="#cb7-32"></a>  {</span>
<span id="cb7-33"><a href="#cb7-33"></a>    <span class="cf">if</span> (++wptr &gt;= buf.size()) wptr -= buf.size();</span>
<span id="cb7-34"><a href="#cb7-34"></a>    buf[wptr] = input;</span>
<span id="cb7-35"><a href="#cb7-35"></a></span>
<span id="cb7-36"><a href="#cb7-36"></a>    <span class="cf">if</span> (++rptr &gt;= buf.size()) rptr -= buf.size();</span>
<span id="cb7-37"><a href="#cb7-37"></a>    <span class="cf">return</span> buf[rptr];</span>
<span id="cb7-38"><a href="#cb7-38"></a>  }</span>
<span id="cb7-39"><a href="#cb7-39"></a>};</span>
<span id="cb7-40"><a href="#cb7-40"></a></span>
<span id="cb7-41"><a href="#cb7-41"></a><span class="co">// メモリの確保と解放を減らした std::deque の代用データ構造。</span></span>
<span id="cb7-42"><a href="#cb7-42"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> RingQueue {</span>
<span id="cb7-43"><a href="#cb7-43"></a>  <span class="bu">std::</span>vector&lt;T&gt; buf;</span>
<span id="cb7-44"><a href="#cb7-44"></a>  <span class="dt">size_t</span> wptr = <span class="dv">0</span>;</span>
<span id="cb7-45"><a href="#cb7-45"></a>  <span class="dt">size_t</span> rptr = <span class="dv">0</span>;</span>
<span id="cb7-46"><a href="#cb7-46"></a></span>
<span id="cb7-47"><a href="#cb7-47"></a>  <span class="dt">void</span> resize(<span class="dt">size_t</span> size) { buf.resize(size); }</span>
<span id="cb7-48"><a href="#cb7-48"></a></span>
<span id="cb7-49"><a href="#cb7-49"></a>  <span class="dt">void</span> reset(T value = <span class="dv">0</span>) { <span class="bu">std::</span>fill(buf.begin(), buf.end(), value); }</span>
<span id="cb7-50"><a href="#cb7-50"></a></span>
<span id="cb7-51"><a href="#cb7-51"></a>  <span class="kw">inline</span> <span class="dt">size_t</span> size()</span>
<span id="cb7-52"><a href="#cb7-52"></a>  {</span>
<span id="cb7-53"><a href="#cb7-53"></a>    <span class="kw">auto</span> sz = wptr - rptr;</span>
<span id="cb7-54"><a href="#cb7-54"></a>    <span class="cf">if</span> (sz &gt;= buf.size()) sz += buf.size(); <span class="co">// Unsigned overflow case.</span></span>
<span id="cb7-55"><a href="#cb7-55"></a>    <span class="cf">return</span> sz;</span>
<span id="cb7-56"><a href="#cb7-56"></a>  }</span>
<span id="cb7-57"><a href="#cb7-57"></a></span>
<span id="cb7-58"><a href="#cb7-58"></a>  <span class="kw">inline</span> <span class="dt">bool</span> empty() { <span class="cf">return</span> wptr == rptr; }</span>
<span id="cb7-59"><a href="#cb7-59"></a></span>
<span id="cb7-60"><a href="#cb7-60"></a>  T &amp;front() { <span class="cf">return</span> buf[increment(rptr)]; }</span>
<span id="cb7-61"><a href="#cb7-61"></a>  T &amp;back() { <span class="cf">return</span> buf[wptr]; }</span>
<span id="cb7-62"><a href="#cb7-62"></a></span>
<span id="cb7-63"><a href="#cb7-63"></a>  <span class="kw">inline</span> <span class="dt">size_t</span> increment(<span class="dt">size_t</span> idx)</span>
<span id="cb7-64"><a href="#cb7-64"></a>  {</span>
<span id="cb7-65"><a href="#cb7-65"></a>    <span class="cf">if</span> (++idx &gt;= buf.size()) idx -= buf.size();</span>
<span id="cb7-66"><a href="#cb7-66"></a>    <span class="cf">return</span> idx;</span>
<span id="cb7-67"><a href="#cb7-67"></a>  }</span>
<span id="cb7-68"><a href="#cb7-68"></a></span>
<span id="cb7-69"><a href="#cb7-69"></a>  <span class="kw">inline</span> <span class="dt">size_t</span> decrement(<span class="dt">size_t</span> idx)</span>
<span id="cb7-70"><a href="#cb7-70"></a>  {</span>
<span id="cb7-71"><a href="#cb7-71"></a>    <span class="cf">if</span> (--idx &gt;= buf.size()) idx += buf.size(); <span class="co">// Unsigned overflow case.</span></span>
<span id="cb7-72"><a href="#cb7-72"></a>    <span class="cf">return</span> idx;</span>
<span id="cb7-73"><a href="#cb7-73"></a>  }</span>
<span id="cb7-74"><a href="#cb7-74"></a></span>
<span id="cb7-75"><a href="#cb7-75"></a>  <span class="dt">void</span> push_back(T value)</span>
<span id="cb7-76"><a href="#cb7-76"></a>  {</span>
<span id="cb7-77"><a href="#cb7-77"></a>    wptr = increment(wptr);</span>
<span id="cb7-78"><a href="#cb7-78"></a>    buf[wptr] = value;</span>
<span id="cb7-79"><a href="#cb7-79"></a>  }</span>
<span id="cb7-80"><a href="#cb7-80"></a></span>
<span id="cb7-81"><a href="#cb7-81"></a>  T pop_front()</span>
<span id="cb7-82"><a href="#cb7-82"></a>  {</span>
<span id="cb7-83"><a href="#cb7-83"></a>    rptr = increment(rptr);</span>
<span id="cb7-84"><a href="#cb7-84"></a>    <span class="cf">return</span> buf[rptr];</span>
<span id="cb7-85"><a href="#cb7-85"></a>  }</span>
<span id="cb7-86"><a href="#cb7-86"></a></span>
<span id="cb7-87"><a href="#cb7-87"></a>  T pop_back()</span>
<span id="cb7-88"><a href="#cb7-88"></a>  {</span>
<span id="cb7-89"><a href="#cb7-89"></a>    wptr = decrement(wptr);</span>
<span id="cb7-90"><a href="#cb7-90"></a>    <span class="cf">return</span> buf[wptr];</span>
<span id="cb7-91"><a href="#cb7-91"></a>  }</span>
<span id="cb7-92"><a href="#cb7-92"></a>};</span>
<span id="cb7-93"><a href="#cb7-93"></a></span>
<span id="cb7-94"><a href="#cb7-94"></a><span class="co">/*</span></span>
<span id="cb7-95"><a href="#cb7-95"></a><span class="co">理想的なホールドの実装。</span></span>
<span id="cb7-96"><a href="#cb7-96"></a><span class="co">- `setFrames(0)` のとき出力はすべて 0 。</span></span>
<span id="cb7-97"><a href="#cb7-97"></a><span class="co">- `setFrames(1)` のとき入力をバイパス。</span></span>
<span id="cb7-98"><a href="#cb7-98"></a><span class="co">*/</span></span>
<span id="cb7-99"><a href="#cb7-99"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Sample&gt; <span class="kw">struct</span> PeakHold {</span>
<span id="cb7-100"><a href="#cb7-100"></a>  Sample neutral = <span class="dv">0</span>;</span>
<span id="cb7-101"><a href="#cb7-101"></a>  Delay&lt;Sample&gt; delay;</span>
<span id="cb7-102"><a href="#cb7-102"></a>  RingQueue&lt;Sample&gt; hold;</span>
<span id="cb7-103"><a href="#cb7-103"></a></span>
<span id="cb7-104"><a href="#cb7-104"></a>  PeakHold(<span class="dt">size_t</span> size = <span class="dv">65536</span>) {</span>
<span id="cb7-105"><a href="#cb7-105"></a>    resize(size);</span>
<span id="cb7-106"><a href="#cb7-106"></a>    setFrames(<span class="dv">1</span>);</span>
<span id="cb7-107"><a href="#cb7-107"></a>  }</span>
<span id="cb7-108"><a href="#cb7-108"></a></span>
<span id="cb7-109"><a href="#cb7-109"></a>  <span class="dt">void</span> resize(<span class="dt">size_t</span> size)</span>
<span id="cb7-110"><a href="#cb7-110"></a>  {</span>
<span id="cb7-111"><a href="#cb7-111"></a>    delay.resize(size);</span>
<span id="cb7-112"><a href="#cb7-112"></a>    hold.resize(size);</span>
<span id="cb7-113"><a href="#cb7-113"></a>  }</span>
<span id="cb7-114"><a href="#cb7-114"></a></span>
<span id="cb7-115"><a href="#cb7-115"></a>  <span class="dt">void</span> reset()</span>
<span id="cb7-116"><a href="#cb7-116"></a>  {</span>
<span id="cb7-117"><a href="#cb7-117"></a>    delay.reset();</span>
<span id="cb7-118"><a href="#cb7-118"></a>    hold.reset(neutral);</span>
<span id="cb7-119"><a href="#cb7-119"></a>  }</span>
<span id="cb7-120"><a href="#cb7-120"></a></span>
<span id="cb7-121"><a href="#cb7-121"></a>  <span class="dt">void</span> setFrames(<span class="dt">size_t</span> frames) { delay.setFrames(frames); }</span>
<span id="cb7-122"><a href="#cb7-122"></a></span>
<span id="cb7-123"><a href="#cb7-123"></a>  Sample process(Sample x0)</span>
<span id="cb7-124"><a href="#cb7-124"></a>  {</span>
<span id="cb7-125"><a href="#cb7-125"></a>    <span class="cf">if</span> (!hold.empty()) {</span>
<span id="cb7-126"><a href="#cb7-126"></a>      <span class="cf">for</span> (<span class="dt">size_t</span> idx = hold.size(); idx &gt; <span class="dv">0</span>; --idx) {</span>
<span id="cb7-127"><a href="#cb7-127"></a>        <span class="cf">if</span> (hold.back() &lt; x0)</span>
<span id="cb7-128"><a href="#cb7-128"></a>          hold.pop_back();</span>
<span id="cb7-129"><a href="#cb7-129"></a>        <span class="cf">else</span></span>
<span id="cb7-130"><a href="#cb7-130"></a>          <span class="cf">break</span>;</span>
<span id="cb7-131"><a href="#cb7-131"></a>      }</span>
<span id="cb7-132"><a href="#cb7-132"></a>    }</span>
<span id="cb7-133"><a href="#cb7-133"></a></span>
<span id="cb7-134"><a href="#cb7-134"></a>    hold.push_back(x0);</span>
<span id="cb7-135"><a href="#cb7-135"></a></span>
<span id="cb7-136"><a href="#cb7-136"></a>    <span class="kw">auto</span> delayOut = delay.process(x0);</span>
<span id="cb7-137"><a href="#cb7-137"></a>    <span class="cf">if</span> (!hold.empty() &amp;&amp; delayOut == hold.front()) hold.pop_front();</span>
<span id="cb7-138"><a href="#cb7-138"></a></span>
<span id="cb7-139"><a href="#cb7-139"></a>    <span class="cf">return</span> !hold.empty() ? hold.front() : neutral;</span>
<span id="cb7-140"><a href="#cb7-140"></a>  }</span>
<span id="cb7-141"><a href="#cb7-141"></a>};</span>
<span id="cb7-142"><a href="#cb7-142"></a></span>
<span id="cb7-143"><a href="#cb7-143"></a><span class="dt">int</span> main()</span>
<span id="cb7-144"><a href="#cb7-144"></a>{</span>
<span id="cb7-145"><a href="#cb7-145"></a>  <span class="co">// PeakHold の使用例。</span></span>
<span id="cb7-146"><a href="#cb7-146"></a>  <span class="kw">constexpr</span> <span class="dt">size_t</span> length = <span class="dv">64</span>;</span>
<span id="cb7-147"><a href="#cb7-147"></a></span>
<span id="cb7-148"><a href="#cb7-148"></a>  PeakHold&lt;<span class="dt">float</span>&gt; hold;</span>
<span id="cb7-149"><a href="#cb7-149"></a>  hold.setFrames(<span class="dv">4</span>);</span>
<span id="cb7-150"><a href="#cb7-150"></a></span>
<span id="cb7-151"><a href="#cb7-151"></a>  <span class="bu">std::</span>minstd_rand rng(<span class="dv">0</span>);</span>
<span id="cb7-152"><a href="#cb7-152"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; dist(<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb7-153"><a href="#cb7-153"></a>  <span class="cf">for</span> (<span class="dt">size_t</span> idx = <span class="dv">0</span>; idx &lt; length; ++idx) {</span>
<span id="cb7-154"><a href="#cb7-154"></a>    <span class="kw">auto</span> input = dist(rng);</span>
<span id="cb7-155"><a href="#cb7-155"></a>    <span class="bu">std::</span>cout &lt;&lt; input &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; hold.process(input) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb7-156"><a href="#cb7-156"></a>  }</span>
<span id="cb7-157"><a href="#cb7-157"></a></span>
<span id="cb7-158"><a href="#cb7-158"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-159"><a href="#cb7-159"></a>}</span></code></pre></div>
<p><code>PeakHold</code> ではニュートラル値 <code>neutral</code> を変更できるようにしています。</p>
<p><code>RingQueue</code> は <code>push_back</code> や <code>pop_front</code> でメモリの確保や解放が行われないようにした <code>std::deque</code> の代替です。速度はほとんど同じです。</p>
<h2 id="その他">その他</h2>
<h3 id="後ろ向きホールド">後ろ向きホールド</h3>
<p>試行錯誤しているときに下の図のような後ろ向きホールドを思いついたのですが、理想的なホールドの生成には使えないことがわかりました。</p>
<figure>
<img src="img/backward_hold.svg" alt="Example plot of backward hold." style="padding-bottom: 12px;"/>
</figure>
<p>前向きホールドと組み合わせて最大値を取ることで理想的なホールドに近づけられます。入力信号を <span class="math inline">\(x\)</span> 、ホールド時間を <span class="math inline">\(d\)</span> 、理想的なホールドを <span class="math inline">\(H_I\)</span> 、 前向きホールドを <span class="math inline">\(H_F\)</span> 、後ろ向きホールドを <span class="math inline">\(H_B\)</span> とすると以下の計算です。</p>
<p><span class="math display">\[
H_I(x) = \max(H_F(x), H_B(x) z^{-d})
\]</span></p>
<p><span class="math inline">\(z^{-d}\)</span> は <span class="math inline">\(d\)</span> サンプルの遅延を表しています。</p>
<p>後ろ向きホールドの実装です。インデックスの並びが逆転している以外は、前向きホールドと同じです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> peakHoldBackward(sig, holdtime, reset<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    out <span class="op">=</span> np.empty(<span class="bu">len</span>(sig))</span>
<span id="cb8-3"><a href="#cb8-3"></a>    hold <span class="op">=</span> reset</span>
<span id="cb8-4"><a href="#cb8-4"></a>    counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(sig))): <span class="co"># ここだけ変更。</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="cf">if</span> counter <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-7"><a href="#cb8-7"></a>            counter <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">else</span>:</span>
<span id="cb8-9"><a href="#cb8-9"></a>            hold <span class="op">=</span> reset</span>
<span id="cb8-10"><a href="#cb8-10"></a>        <span class="cf">if</span> hold <span class="op">&lt;=</span> sig[i]:</span>
<span id="cb8-11"><a href="#cb8-11"></a>            hold <span class="op">=</span> sig[i]</span>
<span id="cb8-12"><a href="#cb8-12"></a>            counter <span class="op">=</span> holdtime</span>
<span id="cb8-13"><a href="#cb8-13"></a>        out[i] <span class="op">=</span> hold</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="cf">return</span> out</span></code></pre></div>
<p>以下は前向きと後ろ向きホールドを組み合わせても理想的なホールドの生成に失敗するケースです。黒い縦線が入力、青い縦線がディレイをかけた入力です。</p>
<figure>
<img src="img/backward_hold_fail.svg" alt="Example plots of a case that backward hold fails to make correct envelope." style="padding-bottom: 12px;"/>
</figure>
<p>前から順に a, b, c の3つピークがあります。以下の条件が揃うと b を見逃してしまうので失敗します。</p>
<ul>
<li>b は a のホールド時間内に現れる。</li>
<li>c は b のホールド時間内に現れる。</li>
<li>a &gt; b かつ c &gt; b 。</li>
</ul>
<footer>
<a href="../index.html">インデックスに戻る</a>
</footer>
</body>

</html>
